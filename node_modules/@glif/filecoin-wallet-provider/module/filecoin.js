import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import LotusRpcEngine from '@glif/filecoin-rpc-client';
import { FilecoinNumber } from '@glif/filecoin-number';
import { checkAddressString } from '@glif/filecoin-address';
import { Message } from '@glif/filecoin-message';
import { computeGasToBurn, KNOWN_TYPE_0_ADDRESS, KNOWN_TYPE_1_ADDRESS, KNOWN_TYPE_3_ADDRESS, allCallsExitWithCode0 } from './utils';
import { BigNumber } from 'bignumber.js';
import { num1GreaterThanNum2 } from './utils';
export class Filecoin {
  constructor(provider, config = {
    apiAddress: 'http://127.0.0.1:1234/rpc/v0'
  }) {
    var _this = this;

    _defineProperty(this, "wallet", void 0);

    _defineProperty(this, "jsonRpcEngine", void 0);

    _defineProperty(this, "getBalance", /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* (address) {
        checkAddressString(address);
        const balance = yield _this.jsonRpcEngine.request('WalletBalance', address);
        return new FilecoinNumber(balance, 'attofil');
      });

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());

    _defineProperty(this, "simulateMessage", /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator(function* (message) {
        const res = yield _this.jsonRpcEngine.request('StateCall', message, null);
        return allCallsExitWithCode0(res);
      });

      return function (_x2) {
        return _ref2.apply(this, arguments);
      };
    }());

    _defineProperty(this, "sendMessage", /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator(function* (message, signature) {
        if (!message) throw new Error('No message provided.');
        if (!signature) throw new Error('No signature provided.');
        const signedMessage = {
          Message: message,
          Signature: {
            // wallet only supports secp256k1 keys for now
            Type: 1,
            Data: signature
          }
        };
        return _this.jsonRpcEngine.request('MpoolPush', signedMessage);
      });

      return function (_x3, _x4) {
        return _ref3.apply(this, arguments);
      };
    }());

    _defineProperty(this, "getNonce", /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator(function* (address) {
        if (!address) throw new Error('No address provided.');
        checkAddressString(address);

        try {
          const nonce = Number(yield _this.jsonRpcEngine.request('MpoolGetNonce', address));
          return nonce;
        } catch (err) {
          if (err && err.message && err.message.toLowerCase().includes('actor not found')) return 0;
          throw new Error(err);
        }
      });

      return function (_x5) {
        return _ref4.apply(this, arguments);
      };
    }());

    _defineProperty(this, "cloneMsgWOnChainFromAddr", /*#__PURE__*/function () {
      var _ref5 = _asyncToGenerator(function* (message) {
        const clonedMsg = Object.assign({}, message);

        try {
          // state call errs if the from address does not exist on chain yet, lookup from actor ID to know this for sure
          yield _this.jsonRpcEngine.request('StateLookupID', clonedMsg.From, null);
        } catch (err) {
          // if from actor doesnt exist, use a hardcoded known actor address
          if (err.message.toLowerCase().includes('actor not found')) {
            const networkPrefix = clonedMsg.From[0];
            if (!clonedMsg.From) clonedMsg.From = KNOWN_TYPE_0_ADDRESS[networkPrefix];
            if (clonedMsg.From[1] === '0') clonedMsg.From = KNOWN_TYPE_0_ADDRESS[networkPrefix];else if (clonedMsg.From[1] === '1') clonedMsg.From = KNOWN_TYPE_1_ADDRESS[networkPrefix];else if (clonedMsg.From[1] === '3') clonedMsg.From = KNOWN_TYPE_3_ADDRESS[networkPrefix];else {
              // this should never happen, only t1 and t3 addresses can be used as a from?
              clonedMsg.From = KNOWN_TYPE_0_ADDRESS[networkPrefix];
            }
          }
        }

        return clonedMsg;
      });

      return function (_x6) {
        return _ref5.apply(this, arguments);
      };
    }());

    _defineProperty(this, "gasEstimateFeeCap", /*#__PURE__*/function () {
      var _ref6 = _asyncToGenerator(function* (message) {
        if (!message) throw new Error('No message provided.');
        const clonedMsg = yield _this.cloneMsgWOnChainFromAddr(message);
        const feeCap = yield _this.jsonRpcEngine.request('GasEstimateFeeCap', clonedMsg, 0, null);
        return new FilecoinNumber(feeCap, 'attofil');
      });

      return function (_x7) {
        return _ref6.apply(this, arguments);
      };
    }());

    _defineProperty(this, "gasEstimateGasLimit", /*#__PURE__*/function () {
      var _ref7 = _asyncToGenerator(function* (message) {
        if (!message) throw new Error('No message provided.');
        const clonedMsg = yield _this.cloneMsgWOnChainFromAddr(message);
        const gasLimit = yield _this.jsonRpcEngine.request('GasEstimateGasLimit', clonedMsg, null);
        return new FilecoinNumber(gasLimit, 'attofil');
      });

      return function (_x8) {
        return _ref7.apply(this, arguments);
      };
    }());

    _defineProperty(this, "gasEstimateGasPremium", /*#__PURE__*/function () {
      var _ref8 = _asyncToGenerator(function* (message, numBlocksIncluded = 0) {
        if (!message) throw new Error('No message provided.');
        const clonedMsg = yield _this.cloneMsgWOnChainFromAddr(message);
        const gasPremium = yield _this.jsonRpcEngine.request('GasEstimateGasPremium', numBlocksIncluded, clonedMsg.From, clonedMsg.GasLimit || 0, null);
        return new FilecoinNumber(gasPremium, 'attofil');
      });

      return function (_x9) {
        return _ref8.apply(this, arguments);
      };
    }());

    _defineProperty(this, "gasEstimateMessageGas", /*#__PURE__*/function () {
      var _ref9 = _asyncToGenerator(function* (message, maxFee = new FilecoinNumber('0.1', 'fil').toAttoFil()) {
        if (!message) throw new Error('No message provided.');
        const clonedMsg = yield _this.cloneMsgWOnChainFromAddr(message);
        const {
          To,
          Value,
          GasPremium,
          GasFeeCap,
          GasLimit,
          Method,
          Nonce,
          Params
        } = yield _this.jsonRpcEngine.request('GasEstimateMessageGas', clonedMsg, {
          MaxFee: maxFee
        }, null); // this is a hack to get by weird UI bugs where f addresses convert to t addresses

        const toAddressWithCorrectPrefix = clonedMsg.To[0] + To.slice(1);
        return new Message({
          to: toAddressWithCorrectPrefix,
          from: message.From,
          value: Value,
          gasPremium: GasPremium,
          gasFeeCap: GasFeeCap,
          gasLimit: GasLimit,
          method: Method,
          nonce: Nonce,
          params: Params
        });
      });

      return function (_x10) {
        return _ref9.apply(this, arguments);
      };
    }());

    _defineProperty(this, "gasEstimateMaxFee", /*#__PURE__*/function () {
      var _ref10 = _asyncToGenerator(function* (message) {
        const msgWithGas = (yield _this.gasEstimateMessageGas(message)).toLotusType();
        const feeCap = new BigNumber(msgWithGas.GasFeeCap);
        const limit = new BigNumber(msgWithGas.GasLimit);
        return {
          maxFee: new FilecoinNumber(feeCap.times(limit), 'attofil'),
          message: msgWithGas
        };
      });

      return function (_x11) {
        return _ref10.apply(this, arguments);
      };
    }());

    _defineProperty(this, "gasCalcTxFee", /*#__PURE__*/function () {
      var _ref11 = _asyncToGenerator(function* (gasFeeCap, gasPremium, gasLimit, baseFee, gasUsed) {
        const gasFeeCapBN = new BigNumber(gasFeeCap);
        const gasPremiumBN = new BigNumber(gasPremium);
        const gasLimitBN = new BigNumber(gasLimit);
        const baseFeeBN = new BigNumber(baseFee);
        const gasUsedBN = new BigNumber(gasUsed);
        /* compute left side */

        const gasToBurn = computeGasToBurn(gasUsedBN, gasLimitBN);
        const totalGas = gasUsedBN.plus(gasToBurn);
        const minBaseFeeFeeCap = BigNumber.minimum(baseFeeBN, gasFeeCapBN);
        const leftSide = totalGas.times(minBaseFeeFeeCap);
        /* compute right side */

        const minTip = BigNumber.minimum(gasFeeCapBN.minus(baseFeeBN), gasPremiumBN);
        const rightSide = gasLimitBN.times(BigNumber.maximum(0, minTip));
        return new FilecoinNumber(leftSide.plus(rightSide), 'attofil');
      });

      return function (_x12, _x13, _x14, _x15, _x16) {
        return _ref11.apply(this, arguments);
      };
    }());

    _defineProperty(this, "getReplaceMessageGasParams", /*#__PURE__*/function () {
      var _ref12 = _asyncToGenerator(function* (message, maxFee = new FilecoinNumber('0.1', 'fil').toAttoFil()) {
        const {
          gasFeeCap: minGasFeeCap,
          gasLimit: minGasLimit,
          gasPremium: minGasPremium
        } = yield _this.getReplaceMessageMinGasParams(message);

        const copiedMessage = _objectSpread({}, message);

        copiedMessage.GasFeeCap = '0';
        copiedMessage.GasPremium = '0';
        copiedMessage.GasLimit = 0;
        const {
          GasFeeCap: recommendedGasFeeCap,
          GasLimit: recommendedGasLimit,
          GasPremium: recommendedGasPremium
        } = (yield _this.gasEstimateMessageGas(copiedMessage, maxFee)).toLotusType(); // assume we take the recommended prices

        let takeMin = false; // if any of the minimum amounts are greater than the recommended,
        // take the minimum amounts

        if (num1GreaterThanNum2(minGasFeeCap, recommendedGasFeeCap)) takeMin = true;
        if (num1GreaterThanNum2(minGasLimit, recommendedGasLimit)) takeMin = true;
        if (num1GreaterThanNum2(minGasPremium, recommendedGasPremium)) takeMin = true;

        if (takeMin) {
          return {
            gasFeeCap: minGasFeeCap,
            gasLimit: minGasLimit,
            gasPremium: minGasPremium
          };
        }

        return {
          gasFeeCap: recommendedGasFeeCap,
          gasLimit: recommendedGasLimit,
          gasPremium: recommendedGasPremium
        };
      });

      return function (_x17) {
        return _ref12.apply(this, arguments);
      };
    }());

    _defineProperty(this, "getReplaceMessageMinGasParams", /*#__PURE__*/function () {
      var _ref13 = _asyncToGenerator(function* (message) {
        let newFeeCap = message.GasFeeCap;
        const newPremium = new BigNumber(message.GasPremium).multipliedBy(125).dividedBy(100);

        if (newPremium.isGreaterThan(message.GasFeeCap)) {
          newFeeCap = newPremium.toFixed(0, BigNumber.ROUND_CEIL);
        }

        return {
          gasFeeCap: newFeeCap,
          gasPremium: newPremium.toFixed(0, BigNumber.ROUND_CEIL),
          gasLimit: message.GasLimit
        };
      });

      return function (_x18) {
        return _ref13.apply(this, arguments);
      };
    }());

    if (!provider) throw new Error('No provider provided.');
    this.wallet = provider;
    this.jsonRpcEngine = new LotusRpcEngine(config);
  }

}
//# sourceMappingURL=filecoin.js.map